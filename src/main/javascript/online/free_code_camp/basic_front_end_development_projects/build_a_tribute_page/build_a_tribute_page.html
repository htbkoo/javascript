<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Build a Tribute Page</title>
    <link href="https://fonts.googleapis.com/css?family=Sahitya|Share+Tech+Mono|Yanone+Kaffeesatz" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            font-family: "Yanone Kaffeesatz";
            color: white;
            font-size: 18px;
            letter-spacing: 1.5px;
            line-height: 1.5em;
        }
        * {
            box-sizing: border-box;
        }

        h1, h2 {
            font-family: "Sahitya";
            text-shadow: 0 0 4px white, 3px 3px 1px black;
            line-height: 1.2em;
        }
        h1 {
            font-size: 4em;
        }
        h2 {
            font-size: 2.5em;
        }
        code, pre {
            font-family: "Share Tech Mono";
            font-size: 0.8em;
        }
        .scene {
            height: 150vh;
            padding: 5vh 10vw;
        }

        .parallax {
            background-size: cover;
            box-sizing: border-box;
            width: 100%;
            height: 130vh;
            /* Since the parallax elements still consume space, we set the margin to undo
               the height of this parallax element making it essentially consume 0 space.
            */
            margin-bottom: -130vh;
        }

        .header {
            height: 70vh;
        }
        .parallax.header {
            margin-bottom: -70vh;
        }

        p {
            color: white;
            margin: 1em 0;
            z-index: 1;
            position: relative;
        }

        .viewport {
            height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            -webkit-overflow-scrolling: touch;
        }
        .woods:not(.header),
        .sunset:not(.header) {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .sunset:not(.header) {
            align-items: flex-end;
        }
        .solid {
            z-index: 1;
            position: relative;
            height: 70vh;
            font-size: 1.5em;
            line-height: 1.5em;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
        }

        .solid.star {
            background-image: linear-gradient(hsla(240, 90%, 8%, 1) 0%, 99%, hsla(217,24%,71%,0) 100%);
            box-shadow: -10px -10px 20px hsl(240, 90%, 8%);
        }
        .solid.woods {
            background-color: hsl(195, 16%, 49%);
            box-shadow: -10px -10px 20px hsl(195, 16%, 49%);
        }
        a, a:link, a:active, a:hover, a:visited {
            color: hsl(240, 100%, 90%);
            display: flex;
            align-items: flex-end;
        }
    </style>
    <style>
        .container {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            overflow-y: scroll;
            perspective: 1px;
            perspective-origin: 0 0;
        }

        .parallax-container {
            transform-style: preserve-3d;
        }

        .parallax-child {
            transform-origin: 0 0;
            transform: translateZ(-2px) scale(3);
        }
    </style>
</head>
<body>

<div class="container">
    <div class=" parallax-container">
        <div class="parallax-child">
            <h1 class="title parallax-container">
                PIANO
            </h1>
        </div>
        <div class="parallax-child">
            <h2 class="subtitle parallax-container">
                a crucial instrument in many musical genres
            </h2>
        </div>
        <div class="parallax-child">
            <div class="parallax-container">
                See more about the instrument piano in this <a href="https://en.wikipedia.org/wiki/Piano">Wikipedia entry</a>
            </div>
        </div>
    </div>
</div>

<!--Reference: https://github.com/GoogleChrome/ui-element-samples/blob/gh-pages/parallax/index.html -->
<div class="viewport">
    <div>
        <!-- Specifying a parallax rate of 0.3 will slide the image at that proportion of the scroll speed. -->
        <div class="parallax header" style="background-image: url('images/stars.jpg');" parallax="0.3"></div>
        <div class="scene header">
            <h1>Gazing into the stars&nbsp;&nbsp;üê±</h1>
            <h2>When cats use <code>requestIdleCallback</code></h2>
        </div>
        <div class="scene solid star">
            <p>
                What‚Äôs this? This is a parallax scroller. But not just yet another parallax scroller, it‚Äôs one that doesn‚Äôt rely on JavaScript for the animation, that works on both desktop and mobile and has 60fps while scrolling. This was a lot harder than we originally anticipated, so we wrote up what we did for you to read!
            </p>
            <p>
                <a href="https://developers.google.com/web/updates/2016/12/performant-parallaxing">
                    <img src="images/screengrab.jpg" style="width: 10vw; float: left; margin-right: 2vw;">
                    Read the article on developers.google.com!</a>
            </p>
        </div>
        <!-- When a rate isn't specified, it will be calculated such that the image always fills the space between the
             element before it and the next element with the "parallax-cover" attribute. -->
        <div class="parallax" style="background-image: url('images/sea.jpg');" parallax></div>
        <div class="scene woods">
            <h1>Gazing into the sea&nbsp;&nbsp;üê≥</h1>
            <h2>Some people don‚Äôt have <code>class</code></h2>
        </div>
        <div class="scene solid woods" parallax-cover>
            <p>
                Lorem ipsum dolor sit amet, et natum mucius quo, nam zril offendit ei. Cu mea amet paulo consequat. Eam nonumy integre malorum ei. Fabulas feugait detracto cu usu. Ad brute moderatius sit, ne mel ullum saperet.
            </p>
            <p>
                Inermis petentium cotidieque sed cu. No duo alienum salutandi. Exerci evertitur vix ea, mei audire conclusionemque an. His nisl graece euismod ad.
            </p>
        </div>
        <!-- When a rate isn't specified and there is no subsequent element with the "parallax-cover" attribute the rate
             will be calculated such that the image slides until the end of the scrollable content. -->
        <div class="parallax" style="background-image: url('images/sunset.jpg');" parallax></div>
        <div class="scene sunset">
            <h1>Gazing into the sunset&nbsp;&nbsp;üåû</h1>
            <h2><code>!important</code> is not a performance primitive</h2>
        </div>
    </div>
</div>

<script>
    // Copied from https://github.com/GoogleChrome/ui-element-samples/blob/gh-pages/parallax/scripts/parallax.js
    /**
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     */

    function initializeParallax(clip) {
        var parallax = clip.querySelectorAll('*[parallax]');
        var parallaxDetails = [];
        var sticky = false;

        // Edge requires a transform on the document body and a fixed position element
        // in order for it to properly render the parallax effect as you scroll.
        // See https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5084491/
        if (getComputedStyle(document.body).transform == 'none')
            document.body.style.transform = 'translateZ(0)';
        var fixedPos = document.createElement('div');
        fixedPos.style.position = 'fixed';
        fixedPos.style.top = '0';
        fixedPos.style.width = '1px';
        fixedPos.style.height = '1px';
        fixedPos.style.zIndex = 1;
        document.body.insertBefore(fixedPos, document.body.firstChild);

        for (var i = 0; i < parallax.length; i++) {
            var elem = parallax[i];
            var container = elem.parentNode;
            if (getComputedStyle(container).overflow != 'visible') {
                console.error('Need non-scrollable container to apply perspective for', elem);
                continue;
            }
            if (clip && container.parentNode != clip) {
                console.warn('Currently we only track a single overflow clip, but elements from multiple clips found.', elem);
            }
            var clip = container.parentNode;
            if (getComputedStyle(clip).overflow == 'visible') {
                console.error('Parent of sticky container should be scrollable element', elem);
            }
            // TODO(flackr): optimize to not redo this for the same clip/container.
            var perspectiveElement;
            if (sticky || getComputedStyle(clip).webkitOverflowScrolling) {
                sticky = true;
                perspectiveElement = container;
            } else {
                perspectiveElement = clip;
                container.style.transformStyle = 'preserve-3d';
            }
            perspectiveElement.style.perspectiveOrigin = 'bottom right';
            perspectiveElement.style.perspective = '1px';
            if (sticky)
                elem.style.position = '-webkit-sticky';
            if (sticky)
                elem.style.top = '0';
            elem.style.transformOrigin = 'bottom right';

            // Find the previous and next elements to parallax between.
            var previousCover = parallax[i].previousElementSibling;
            while (previousCover && previousCover.hasAttribute('parallax'))
                previousCover = previousCover.previousElementSibling;
            var nextCover = parallax[i].nextElementSibling;
            while (nextCover && !nextCover.hasAttribute('parallax-cover'))
                nextCover = nextCover.nextElementSibling;

            parallaxDetails.push({'node': parallax[i],
                'top': parallax[i].offsetTop,
                'sticky': !!sticky,
                'nextCover': nextCover,
                'previousCover': previousCover});
        }

        // Add a scroll listener to hide perspective elements when they should no
        // longer be visible.
        clip.addEventListener('scroll', function() {
            for (var i = 0; i < parallaxDetails.length; i++) {
                var container = parallaxDetails[i].node.parentNode;
                var previousCover = parallaxDetails[i].previousCover;
                var nextCover = parallaxDetails[i].nextCover;
                var parallaxStart = previousCover ? (previousCover.offsetTop + previousCover.offsetHeight) : 0;
                var parallaxEnd = nextCover ? nextCover.offsetTop : container.offsetHeight;
                var threshold = 200;
                var visible = parallaxStart - threshold - clip.clientHeight < clip.scrollTop &&
                    parallaxEnd + threshold > clip.scrollTop;
                // FIXME: Repainting the images while scrolling can cause jank.
                // For now, keep them all.
                // var display = visible ? 'block' : 'none'
                var display = 'block';
                if (parallaxDetails[i].node.style.display != display)
                    parallaxDetails[i].node.style.display = display;
            }
        });
        window.addEventListener('resize', onResize.bind(null, parallaxDetails));
        onResize(parallaxDetails);
        for (var i = 0; i < parallax.length; i++) {
            parallax[i].parentNode.insertBefore(parallax[i], parallax[i].parentNode.firstChild);
        }
    }

    function onResize(details) {
        for (var i = 0; i < details.length; i++) {
            var container = details[i].node.parentNode;

            var clip = container.parentNode;
            var previousCover = details[i].previousCover;
            var nextCover = details[i].nextCover;
            var rate = details[i].node.getAttribute('parallax');

            var parallaxStart = previousCover ? (previousCover.offsetTop + previousCover.offsetHeight) : 0;
            var scrollbarWidth = details[i].sticky ? 0 : clip.offsetWidth - clip.clientWidth;
            var parallaxElem = details[i].sticky ? container : clip;
            var height = details[i].node.offsetHeight;
            var depth = 0;
            if (rate) {
                depth = 1 - (1 / rate);
            } else {
                var parallaxEnd = nextCover ? nextCover.offsetTop : container.offsetHeight;
                depth = (height - parallaxEnd + parallaxStart) / (height - clip.clientHeight);
            }
            if (details[i].sticky)
                depth = 1.0 / depth;

            var scale = 1.0 / (1.0 - depth);

            // The scrollbar is included in the 'bottom right' perspective origin.
            var dx = scrollbarWidth * (scale - 1);
            // Offset for the position within the container.
            var dy = details[i].sticky ?
                -(clip.scrollHeight - parallaxStart - height) * (1 - scale) :
                (parallaxStart - depth * (height - clip.clientHeight)) * scale;

            details[i].node.style.transform = 'scale(' + (1 - depth) + ') translate3d(' + dx + 'px, ' + dy + 'px, ' + depth + 'px)';
        }
    }
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        initializeParallax(document.querySelector('.viewport'));
    });
</script>
</body>
</html>